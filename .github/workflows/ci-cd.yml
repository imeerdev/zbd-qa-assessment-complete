# CI/CD Pipeline for Payment API
# Demonstrates comprehensive testing, quality gates, and deployment automation

name: CI/CD Pipeline

# TRIGGER CONDITIONS
# When should this pipeline run?
on:
  # Run on every push to main branch
  push:
    branches: [ main, develop ]
  
  # Run on every pull request targeting main
  pull_request:
    branches: [ main ]
  
  # Allow manual trigger from Actions tab
  workflow_dispatch:
  
  # Run daily at 2 AM UTC to catch dependency issues
  schedule:
    - cron: '0 2 * * *'

# ENVIRONMENT VARIABLES
# Accessible across all jobs
env:
  NODE_VERSION: '18.x'
  MIN_COVERAGE: 80  # Minimum test coverage required

# JOBS
# Each job runs in a fresh environment
jobs:
  
  # ============================================
  # JOB 1: CODE QUALITY CHECKS
  # Fast checks that fail early if code is bad
  # ============================================
  code-quality:
    name: Code Quality & Linting
    runs-on: ubuntu-latest
    
    steps:
      # STEP 1: Checkout code from repository
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # Fetch full history for better analysis
          fetch-depth: 0
      
      # STEP 2: Set up Node.js environment
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          # Cache npm dependencies for faster builds
          cache: 'npm'
          cache-dependency-path: HandsOnExerciseABC/package-lock.json
      
      # STEP 3: Install dependencies
      - name: Install dependencies
        working-directory: HandsOnExerciseABC
        run: |
          npm ci  # Clean install (faster and more reliable than npm install)
      
      # STEP 4: Run linter (ESLint)
      # Commented out since we don't have .eslintrc, but shows the pattern
      # - name: Run ESLint
      #   run: npm run lint
      #   continue-on-error: false  # BLOCK merge if linting fails
      
      # STEP 5: Check for security vulnerabilities
      - name: Security audit
        working-directory: HandsOnExerciseABC
        run: |
          npm audit --audit-level=moderate
        continue-on-error: true  # Don't block on security issues (alert only)

      # STEP 6: Check for outdated dependencies
      - name: Check for outdated dependencies
        working-directory: HandsOnExerciseABC
        run: |
          npm outdated || true
        continue-on-error: true
  
  # ============================================
  # JOB 2: UNIT & INTEGRATION TESTS
  # Core functionality testing
  # ============================================
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    # DEPENDENCY: Only run after code-quality passes
    needs: code-quality
    
    # MATRIX STRATEGY: Test on multiple Node versions
    strategy:
      matrix:
        node-version: [16.x, 18.x, 20.x]
      # Don't cancel other matrix jobs if one fails
      fail-fast: false
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          cache-dependency-path: HandsOnExerciseABC/package-lock.json

      - name: Install dependencies
        working-directory: HandsOnExerciseABC
        run: npm ci

      # CRITICAL STEP: Run tests with coverage
      - name: Run tests with coverage
        working-directory: HandsOnExerciseABC
        run: |
          npm test -- --coverage --coverageReporters=json-summary --coverageReporters=text

      # QUALITY GATE: Check coverage threshold
      - name: Check coverage threshold
        working-directory: HandsOnExerciseABC
        run: |
          COVERAGE=$(cat coverage/coverage-summary.json | jq '.total.lines.pct')
          echo "Test coverage: ${COVERAGE}%"

          if (( $(echo "$COVERAGE < $MIN_COVERAGE" | bc -l) )); then
            echo "❌ Coverage ${COVERAGE}% is below minimum ${MIN_COVERAGE}%"
            exit 1
          else
            echo "✅ Coverage ${COVERAGE}% meets minimum ${MIN_COVERAGE}%"
          fi

      # Upload coverage report as artifact
      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-node-${{ matrix.node-version }}
          path: HandsOnExerciseABC/coverage/
          retention-days: 30
      
      # OPTIONAL: Send coverage to Codecov
      # - name: Upload to Codecov
      #   uses: codecov/codecov-action@v3
      #   with:
      #     token: ${{ secrets.CODECOV_TOKEN }}
      #     files: ./coverage/coverage-final.json
  
  # ============================================
  # JOB 3: BUILD & PACKAGE
  # Ensure code can be built/packaged
  # ============================================
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: HandsOnExerciseABC/package-lock.json

      - name: Install dependencies
        working-directory: HandsOnExerciseABC
        run: npm ci

      # If this were a web app, we'd build it here
      - name: Build application
        working-directory: HandsOnExerciseABC
        run: |
          echo "Building application..."
          # npm run build (if we had a build step)
          echo "✅ Build successful"

      # Package the application
      - name: Create distribution package
        working-directory: HandsOnExerciseABC
        run: |
          mkdir -p dist
          cp payment-api.js dist/
          cp functional-tests.test.js dist/
          cp package*.json dist/
          tar -czf payment-api-${{ github.sha }}.tar.gz dist/

      # Upload build artifact
      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-artifact
          path: HandsOnExerciseABC/payment-api-*.tar.gz
          retention-days: 7
  
  # ============================================
  # JOB 4: INTEGRATION TESTS (Optional)
  # Test with external dependencies
  # ============================================
  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: build
    
    # This job is optional and won't block deployment
    continue-on-error: true
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: HandsOnExerciseABC/package-lock.json

      - name: Install dependencies
        working-directory: HandsOnExerciseABC
        run: npm ci

      # Example: Start a mock API server for integration tests
      - name: Start mock services
        working-directory: HandsOnExerciseABC
        run: |
          # In a real scenario, you might use Docker Compose here
          echo "Starting mock services..."
          # docker-compose up -d

      - name: Run integration tests
        working-directory: HandsOnExerciseABC
        run: |
          # npm run test:integration
          echo "Integration tests would run here"
  
  # ============================================
  # JOB 5: SECURITY SCANNING
  # Check for known vulnerabilities
  # ============================================
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: test
    
    # Run even if previous jobs failed (we want to know about security issues)
    if: always()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: HandsOnExerciseABC/package-lock.json

      - name: Install dependencies
        working-directory: HandsOnExerciseABC
        run: npm ci

      # Run npm audit
      - name: Run npm audit
        working-directory: HandsOnExerciseABC
        run: |
          npm audit --json > audit-results.json || true
          cat audit-results.json

      # OPTIONAL: Use third-party security scanners
      # - name: Run Snyk security scan
      #   uses: snyk/actions/node@master
      #   env:
      #     SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      - name: Upload security scan results
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results
          path: HandsOnExerciseABC/audit-results.json
          retention-days: 30
  
  # ============================================
  # JOB 6: PERFORMANCE TESTS
  # Ensure code meets performance requirements
  # ============================================
  performance-test:
    name: Performance Tests
    runs-on: ubuntu-latest
    needs: build
    
    # Only run on main branch (not on every PR)
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: HandsOnExerciseABC/package-lock.json

      - name: Install dependencies
        working-directory: HandsOnExerciseABC
        run: npm ci

      # Example: Run performance benchmarks
      - name: Run performance benchmarks
        working-directory: HandsOnExerciseABC
        run: |
          echo "Running performance tests..."
          # npm run test:performance

          # Example assertion
          # BENCHMARK=$(npm run bench:silent)
          # if [ $BENCHMARK -gt 1000 ]; then
          #   echo "❌ Performance degradation detected"
          #   exit 1
          # fi
  
  # ============================================
  # JOB 7: DEPLOYMENT (Conditional)
  # Deploy to staging or production
  # ============================================
  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    
    # CRITICAL: Only deploy if ALL previous jobs passed
    needs: [code-quality, test, build, security-scan]
    
    # CONDITION: Only deploy from main branch
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    # Use production environment (requires approval in GitHub settings)
    environment:
      name: production
      url: https://payment-api.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Download build artifact from earlier job
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: build-artifact
      
      # Example: Deploy to a server
      - name: Deploy to production
        run: |
          echo "Deploying to production..."
          # In real scenario:
          # - Upload to S3
          # - Deploy to Kubernetes
          # - Update Lambda function
          # - etc.
          
          echo "✅ Deployment successful"
      
      # CRITICAL: Create a git tag for this release
      - name: Create release tag
        run: |
          VERSION=$(date +%Y.%m.%d-%H%M%S)
          git tag "v$VERSION"
          # git push origin "v$VERSION"
          echo "Created release tag: v$VERSION"
  
  # ============================================
  # JOB 8: NOTIFICATION (Always runs)
  # Notify team of pipeline results
  # ============================================
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    
    # Run after all other jobs, regardless of their status
    needs: [code-quality, test, build, deploy]
    if: always()
    
    steps:
      - name: Check job statuses
        id: check
        run: |
          if [ "${{ needs.test.result }}" == "failure" ]; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "message=Tests failed ❌" >> $GITHUB_OUTPUT
          elif [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "status=deployed" >> $GITHUB_OUTPUT
            echo "message=Deployed to production ✅" >> $GITHUB_OUTPUT
          else
            echo "status=completed" >> $GITHUB_OUTPUT
            echo "message=Pipeline completed" >> $GITHUB_OUTPUT
          fi
      
      # Example: Send Slack notification
      # - name: Send Slack notification
      #   uses: slackapi/slack-github-action@v1.24.0
      #   with:
      #     payload: |
      #       {
      #         "text": "${{ steps.check.outputs.message }}",
      #         "blocks": [
      #           {
      #             "type": "section",
      #             "text": {
      #               "type": "mrkdwn",
      #               "text": "Pipeline ${{ steps.check.outputs.status }} for commit ${{ github.sha }}"
      #             }
      #           }
      #         ]
      #       }
      #   env:
      #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      
      - name: Summary
        run: |
          echo "## Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Status: ${{ steps.check.outputs.message }}" >> $GITHUB_STEP_SUMMARY
          echo "- Commit: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- Branch: ${{ github.ref }}" >> $GITHUB_STEP_SUMMARY

# ============================================
# KEY FEATURES OF THIS PIPELINE
# ============================================
#
# 1. MULTIPLE QUALITY GATES
#    - Linting & code quality
#    - Unit tests with coverage threshold (80%)
#    - Security scanning
#    - Build verification
#
# 2. MATRIX TESTING
#    - Tests run on Node 16, 18, and 20
#    - Ensures compatibility across versions
#
# 3. FAIL-FAST PREVENTION
#    - Bad PRs are blocked automatically
#    - Can't merge if tests fail or coverage is low
#
# 4. ARTIFACT MANAGEMENT
#    - Coverage reports saved for 30 days
#    - Build artifacts saved for 7 days
#    - Easy to download and inspect
#
# 5. CONDITIONAL DEPLOYMENT
#    - Only deploys from main branch
#    - Requires all quality gates to pass
#    - Uses GitHub environments (can require approval)
#
# 6. SECURITY-FIRST
#    - Dependency auditing
#    - Security scanning
#    - Secrets never exposed in logs
#
# 7. OBSERVABILITY
#    - Detailed logs at each step
#    - Coverage metrics tracked
#    - Notifications on failure/success
#
# 8. EFFICIENCY
#    - Caches dependencies (faster builds)
#    - Parallel job execution
#    - Only runs necessary jobs
#
# ============================================
# HOW THIS BLOCKS BAD MERGES
# ============================================
#
# Protected Branch Settings (configure in GitHub):
# 1. Go to Settings → Branches → Add rule
# 2. Branch name pattern: main
# 3. Check: "Require status checks to pass before merging"
# 4. Select required checks:
#    - code-quality
#    - test (all matrix variants)
#    - build
# 5. Check: "Require branches to be up to date"
# 6. Save
#
# Now: PRs cannot be merged unless all checks pass!
#
# ============================================
